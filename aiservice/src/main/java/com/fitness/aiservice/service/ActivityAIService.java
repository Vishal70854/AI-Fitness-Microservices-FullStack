package com.fitness.aiservice.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fitness.aiservice.model.Activity;
import com.fitness.aiservice.model.Recommendation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

// this service is responsible to work with GeminiService and generate recommendations
// from Gemini API
@Service
@Slf4j
@RequiredArgsConstructor    // by this annotation the GeminiService will be automatically injected as we have used final keyword(other variables with final keyword will also we injected using IOC principle)
public class ActivityAIService {

    private final GeminiService geminiService;

    // METHOD FOR GENERATING RECOMMENDATION FROM GEMINI API
    public Recommendation generateRecommendation(Activity activity){

        String prompt = createPromptForActivity(activity);  // create prompt for GEMINI ai
        String aiResponse = geminiService.getAnswer(prompt);    // get recommendations from gemini api
        log.info("RESPONSE FROM AI : {}", aiResponse);
        return processAiResponse(activity,aiResponse); // process the activity and AIResponse to save it in DB
    }

    // parse the recommended JSON data from GEMINI API and save it in DB
    private Recommendation processAiResponse(Activity activity, String aiResponse){
        try {
            // convert JSON data to Java Objects and vice-versa
            ObjectMapper mapper = new ObjectMapper();
            JsonNode rootNode = mapper.readTree(aiResponse);    // read the JSON value using ObjectMapper

            // fetch the text json node from Gemini API response to parse it and save to DB
            JsonNode textNode = rootNode.path("candidates")  // traverse the Json Key-value using path(key)
                    .get(0) // candidates is a Array<Object[]) so get the first element of it i.e "content" json
                    .path("content")
                    .path("parts")
                    .get(0) // parts is a Array<Object[]>, get the first element i.e "text" json
                    .path("text");

            // convert textNode from json to text values
            String jsonContent = textNode.asText()
                    .replaceAll("```json\\n","")
                    .replaceAll("\\n```","")
                    .trim();

//            log.info("PARSED RESPONSE FROM AI : {}", jsonContent);  // print the log in console

            // read the jsonContent(parsedJson) to save it in Recommendation Table and save it in DB
            JsonNode analysisJson = mapper.readTree(jsonContent);
            JsonNode analysisNode = analysisJson.path("analysis");

            StringBuilder fullAnalysis = new StringBuilder();
            addAnalysisSection(fullAnalysis, analysisNode, "overall", "Overall:");
            addAnalysisSection(fullAnalysis, analysisNode, "pace", "Pace:");
            addAnalysisSection(fullAnalysis, analysisNode, "hearRate", "Heart Rate:");
            addAnalysisSection(fullAnalysis, analysisNode, "caloriesBurned", "Calories:");


            // get List of improvements from analysisJson
            List<String> improvements = extractImprovements(analysisJson.path("improvements"));

            // get List of suggestions from analysisJson
            List<String> suggestions = extractSuggestions(analysisJson.path("suggestions"));

            // get List of suggestions from analysisJson
            List<String> safety = extractSafetyGuidelines(analysisJson.path("safety"));

            // pass all the fields of Recommendation from activity and json data using builder() and build();
            return Recommendation.builder()
                    .activityId(activity.getId())
                    .userId(activity.getUserId())
                    .activityType(activity.getType())
                    .recommendation(fullAnalysis.toString().trim())
                    .improvements(improvements)
                    .suggestions(suggestions)
                    .safety(safety)
                    .createdAt(LocalDateTime.now())
                    .build();

        } catch (Exception e) {
            e.printStackTrace();
            return createDefaultRecommendation(activity);
        }
    }
    // if Recommendation is not generated by json then a default or proxy Recommendation is created and returned as response in processAiResponse() method
    private Recommendation createDefaultRecommendation(Activity activity) {

        return Recommendation.builder()
                .activityId(activity.getId())
                .userId(activity.getUserId())
                .activityType(activity.getType())
                .recommendation("Unable to generate detailed analysis")
                .improvements(Collections.singletonList("continue with your health activity"))
                .suggestions(Collections.singletonList("Consider consulting your trainer"))
                .safety(Arrays.asList(
                        "Always warm up before exercise",
                        "Stay hydrated",
                        "Listen to your body"
                ))
                .createdAt(LocalDateTime.now())
                .build();
    }

    // extract List of safety from analysisJson and save it in List<String> safety
    private List<String> extractSafetyGuidelines(JsonNode safetyNode) {


        List<String> safety = new ArrayList<>();
        if(safetyNode.isArray()){
            safetyNode.forEach(item -> safety.add(item.asText()));
        }
        return safety.isEmpty() ?
                Collections.singletonList("Follow general safety guidelines") :
                safety;

    }

    // extract List of suggestion from analysisJson and save it in List<String> suggestions
    private List<String> extractSuggestions(JsonNode suggestionsNode) {

        List<String> suggestions = new ArrayList<>();
        if(suggestionsNode.isArray()){
            suggestionsNode.forEach(suggestion -> {
                String workout = suggestion.path("workout").asText();
                String description = suggestion.path("description").asText();
                suggestions.add(String.format("%s: %s", workout, description));

            });
        }
        return suggestions.isEmpty() ?
                Collections.singletonList("No specific suggestions found") :
                suggestions;
    }

    // get List of improvements as String to store it in List<String> improvements in Recommendation table
    private List<String> extractImprovements(JsonNode improvementsNode) {

        List<String> improvements = new ArrayList<>();

        if(improvementsNode.isArray()){
            improvementsNode.forEach(improvement -> {
                String area = improvement.path("area").asText();
                String detail = improvement.path("recommendation").asText();
                improvements.add(String.format("%s: %s", area, detail));

            });

        }
        return improvements.isEmpty() ?
                Collections.singletonList("No specific improvements provided") :
                improvements;
    }

    // method to do analysis on the analysis key of json response from GEMINI API
    // converting key-value json to String to save it in recommendation field in Recommendation table
    private void addAnalysisSection(StringBuilder fullAnalysis, JsonNode analysisNode, String key, String prefix) {
           if(!analysisNode.path(key).isMissingNode()){
               fullAnalysis.append(prefix)  // prefix for key is "overall:" which is named as prefix in method signature
                       .append(analysisNode.path(key).asText()) // get the key values as text
                       .append("\n\n");
           }
    }

    // create prompt for GEMINI AI to parse and provide recommendations in the below JSON format
    private String createPromptForActivity(Activity activity) {
        return String.format("""
                
                Analyze this fitness activity and provide detailed recommendations in the following EXACT JSON format:
                
                {
                    "analysis" : {
                        "overall": "Overall analysis here",
                        "pace": "Pace analysis here",
                        "heartRate": "Heart rate analysis here",
                        "caloriesBurned": "Calories analysis here", 
                    },
                    "improvements": [
                        {
                            "area": "Area name",
                            "recommendation": "Detailed recommendation"
                        }
                    ],
                    "suggestions": [
                        {
                            "workout": "Workout name",
                            "description": "Detailed workout description"
                        }
                    ],
                    "safety": [
                        "Safety point 1",
                        "Safety point 2"
                    ]
                }
                
                Analyze this activity:
                Activity Type: %s
                Duration: %d minutes
                Calories Burned: %d
                Additional Metrics: %s
                
                Provide detailed analysis focusing on performance, improvements, next workout suggestions, and safety guidelines,
                Ensure the response follows the EXACT JSON format shown above.
                """,
                    activity.getType(),
                    activity.getDuration(),
                    activity.getCaloriesBurned(),
                    activity.getAdditionalMetrics()
        );
    }
}
